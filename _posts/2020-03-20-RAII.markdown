---
layout: post
title:  "资源管理小记"
date:   2020-03-20 19:23:36 +0530
tags: RAII 
categories: [笔记 | Notes]
---
本文主要整理讨论面向对象程序设计中的资源管理.

# <font face="微软雅黑" >1. 为什么要管理资源</font>
&#8195;&#8195;资源是使用前需要获取,使用后需要被释放的东西.
+ 从计算机的角度看, 常见的资源有内存、锁、文件、网络连接等.
+ 从人类的角度看, 资源还可以是**业务逻辑上的实体(entity)**在计算机中的表示,例如运营商、设备、人员等.

&#8195;&#8195;对资源的管理是程序设计中的一个重要问题.
+ 资源是**有限的** -> 资源**需要被释放**(不释放就会导致**泄露leak**) -> 如果程序访问了释放的资源就可能发生**异常(exception)**


# <font face="微软雅黑" >2. 资源与对象生命周期</font>

>  *Use objects to manage resources. —— Scott Meyers, Effective C++ 3rd Edition*

一般程序里,资源的**生命周期(lifetime)**主要涉及三种操作:

|生命周期 |以面向**过程**程序为例|
|-|-|
|&#8195;获取资源&#8195;|&#8195;打开文件 file = fopen(filename, open_mode)&#8195;|
|&#8195;使用资源&#8195;|&#8195;读写文件 fread/fwrite(buffer, size, count, file)&#8195;|
|&#8195;释放资源&#8195;|&#8195;关闭文件 fclose(file)&#8195;|

+ 对于面向过程语言(C),对资源的操作往往通过函数调用的方式, 如上表所示, 通过调用fopen()获取文件资源,拿到资源的句柄(handled)
+ 再将句柄以参数的形式传入到fread/fwrite中,进行读写(使用文件资源).
+ 使用完后,将文件资源的句柄传入到flcose中, 释放资源.

**面向过程**的语言没有对象的概念, 因此资源的**所有权(ownership)**不够明确.容易忘记释放资源.

而在**面向对象**的程序中, 对象往往作为资源的载体, 申请资源的**对象拥有资源**, 通过管理对象的生命周期实现对资源的管理. 如下表所示, 通过创建file对象来获取文件资源, 通过访问对象的read/write方法来使用资源, 最后在对象销毁时释放文件资源

|生命周期 |以面向**对象**程序为例|
| --- | --- |
|&#8195;获取资源&#8195;|&#8195;打开文件 fstream = file("/usr/eg.txt")&#8195;|
|&#8195;使用资源&#8195;|&#8195;读写文件 file.read(..)/file.write(..)&#8195;|
|&#8195;释放资源&#8195;|&#8195;关闭文件 析构file对象->flie.close()&#8195;|

## <font face="微软雅黑" >2.1 拥有资源对象的销毁</font>

对象的销毁方式主要有两种, 各自有各自的优劣:
+ 手动销毁
    - 不再使用的资源忘记释放, 会导致**泄露**(可以使用RAII机制避免)
    - 使用已经被释放的资源, 会导致**悬垂引用**(可以通过[弱引用](#弱引用映射)机制避免)
    - 释放已经被释放的资源, 会导致**崩溃** 

+ 自动销毁
    - 资源的释放位置和时间不可控, 往往依赖于垃圾回收机制的实现.

## <font face="微软雅黑" >2.2 C++是怎么做的</font>

C++出于对性能的追求, 不支持自动销毁机制. 但是为了解决C语言里资源所有权不明确的问题, modern C++提出了更加方便的资源安全机制:&#8195;[RAII(Resource acquisition is initialization)机制](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization), 明确了资源的所有权,避免资源泄露. 一些例子:
+ 局部指针变量需不要置为空?RAII机制保证了这是多余的;
+ 锁封装成类, 构造函数lock,析构函数unlock)

# <font face="微软雅黑" >3. 资源和对象的映射关系</font>

> *Item 14: Think carefully about copying behavior in resource-managing classes. —— Scott Meyers, Effective C++ 3rd Edition*

用于资源管理的对象, 在使用他的**拷贝语义**时要小心:
+ 如果资源是不可拷贝的, 那么这个对象也是不可拷贝的.
+ 如果资源可以拷贝, 那么对象的拷贝会导致管理的资源的拷贝.

这就涉及到了资源和对象的**映射关系**

## <font face="微软雅黑" >3.1 一对一映射</font>
同一个资源, 在系统中由一个对象来管理,一个这个对象是**不可拷贝的**(non-copyable), 当我们不希望某个资源被拷贝时,可以采取这种映射关系.
+ **互斥所有权**(exclusive ownership): 这个对象创建时申请资源, 销毁时释放资源.
+ 对这个对象的**读取和修改**,直接映射到对资源的**读取和修改**上.

## <font face="微软雅黑" >3.2 多对一映射</font>
同一个资源, 在系统中由多个对象来管理,多个对象共享一个资源.
+ **共享所有权**(shared ownership): 第一个对象创建时申请资源, 所有对象都销毁时,释放资源.
+ 对任意一个对象的**读取**, 都直接映射到对资源的**读取**上.
+ **修改**其中一个对象, 如果是**可变对象(引用语义)**实现, 不仅会修改当前对象表示的资源,还会把修改应用到其他拥有这个资源的对象上. 如果是**不可变对象(值语义)**实现, 相当于只对资源的副本进行了修改.不影响其他对象, 如果要保证数据的一致性, 需要手动修改其他对象.

## <font face="微软雅黑" >3.3 弱引用映射</font>
一些场景下,我们仅需要使用一个资源对象，而不需要管理它的生命周期，也就是不拥有这个资源.

一般使用**强引用**表示拥有资源的引用关系([一对一](#一对一映射) /[多对一](#多对一映射)), 而使用弱引用表示不拥有资源的引用关系.
+ 不涉及资源的申请和释放, 但需要指定引用一个强引用对象.
+ 如果被引用对象还有效，读取和修改这个弱引用对象，和直接操作被引用对象一致.
+ 如果被引用对象无效，不能读取或修改这个弱引用对象

## <font face="微软雅黑" >3.4 C++怎么做的?</font>

|实现方式|映射方式|可拷贝|修改同步|失效同步|
|-|-|-|-|-|
|&#8195;unique_ptr&#8195;|&#8195;一对一强引用&#8195;|&#8195;×&#8195;|&#8195;√&#8195;|&#8195;-&#8195;|
|&#8195;shared_ptr&#8195;|&#8195;多对一强引用&#8195;|&#8195;√&#8195;|&#8195;√&#8195;|&#8195;√&#8195;|
|&#8195;值对象&#8195;|&#8195;多对一强引用&#8195;|&#8195;√&#8195;|&#8195;×&#8195;|&#8195;×&#8195;|
|&#8195;weak_ptr&#8195;|&#8195;弱引用&#8195;|&#8195;√&#8195;|&#8195;√&#8195;|&#8195;√&#8195;|
|&#8195;普通指针&#8195;|&#8195;弱引用&#8195;|&#8195;√&#8195;|&#8195;√&#8195;|&#8195;×&#8195;|


# The Tail End
&#8195;&#8195;显然c++'麻烦'的地方就在于内存管理, Java、C#、Go都自带垃圾回收机制,不用程序员自己管理内存, 而我们需要去手动管理, 这其实也是C++灵活的地方, 不断学习新的工具与方法去驾驭这种灵活, 而不是被这灵活带来的代价所吞噬. 做一个合格的程序员~ 后续如果有机会对这一块做更加系统的学习也会在这里与大家分享~
