---
layout: post
title:  "C++性能优化笔记"
date:   2020-02-20 20:40:36 +0530
tags: cpu
categories: [代码 | Coding]
---
性能优化, 拿到这个任务的之后经常会觉得有劲儿没处使, 正好赶上疫情,时间比较充足,花了很多时间和精力去研究如何优化,需要学习的东西很多, 逐步积累, 做个笔记:pencil:

# 为什么写这篇文章?

&#8195;&#8195;性能问题和Bug不同，后者的分析和解决思路更清晰，很多时候从应用日志（文中的应用指分布式服务下的单个节点）即可直接找到问题根源，而性能问题，其排查思路更为复杂一些。

&#8195;&#8195;对应用进行性能优化，是一个**系统性的工程，对工程师的技术广度和技术深度都有所要求**。一个简单的应用，它不仅包含了应用代码本身，还和容器（虚拟机）、操作系统、存储、网络、文件系统等紧密相关，线上应用一旦出现了性能问题，需要我们从多方面去考虑。

&#8195;&#8195;与此同时，除了一些低级的代码逻辑引发的性能问题外，很多性能问题隐藏的较深，排查起来会比较困难，需要我们对应用的各个子模块、应用所使用的框架和组件的原理有所了解，同时掌握一定的性能优化工具和经验。

&#8195;&#8195;可见, 要想很好的应对性能问题, 是需要一个**工具与技术的积累**的. 正好后台代码的性能优化是我上半年的一个非常重要的OKR指标, 下了很大功夫, 所以这里做个总结与大家分享~ 


# 性能优化从何做起?

&#8195;&#8195;性能本身就是一个笼统的概念, 首先弄清楚我们关注的性能指标具体是什么,&ensp;Cpu,内存,网络等,这些都是性能指标.&ensp;而Cpu性能需要优化又分为两种情况:**cpu利用率高&平均负载高**以及**cpu利用低&平均负载高**, 本文的工作是针对前者展开的.
在弄清楚要优化目标之后,先别着急开始动手分析改代码,准备阶段还有一些重要的工作要做:


1) **对性能问题进行粗略的评估,** &ensp;过滤一些因为低级的业务逻辑导致的性能问题。


2) **了解应用的总体架构,** &ensp;比如外部依赖与核心接口、哪些使用频率较高、哪些可以进行修改、上下游数据链路是怎样的等等.


3) **了解应用对应的服务信息,** &ensp;cpu信息、服务器机器版本信息、是容器还是虚拟机、有没有和其他服务混跑等等.


这些工作的目的就是搞一个基准数据出来,结合基准数据和当前的一些业务指标, 确定此次性能优化的最终指标,这里的指标就是一个确切的数值了,比如某个服务,在基准指标下,cpu负载达到z%. 测试有了基准数据以后,开发有任何想要优化的改动都可以交由测试快速完成性能对比,给出反馈,最终达成目标.


# 工具

&#8195;&#8195;工欲善其事，必先利其器. 大佬们已经总结好了性能工具图(Linux Performance Tools-full), 在这里贴一下. [更多详细内容](http://www.brendangregg.com/linuxperf.html?spm=a2c6h.12873639.0.0.dea57ee2dxWa83)

![avatar](https://github.com/SonderEASE/lewis-blog.io/blob/master/pics/linux_observability_tools.png?raw=true)

&#8195;&#8195;看上去密密麻麻的, 但是不要慌~ 往往我们只需要聚焦某一点, 比如这里我们只关注Cpu. 那我们重点就是掌握perf以及借助perf生成的火焰图就好了~ 工具我觉得不需要多说什么,只要能用起来,越简单的教程越有价值.比如这个:point_right:[无脑生成火焰图](https://www.cnblogs.com/happyliu/p/6142929.html)

&#8195;&#8195;还有些常用指令:
+ top
+ pstack pid
+ gstack pid
+ ps -Lp pid cu
+ ...

# 优化列表
+ 2/8原则
    
    程序的性能往往也遵循28原则,也就是说80%的性能开销来自20%的代码.通过Perf火焰图我们可以很快的定位到这20%的代码在哪里,并对其进行优化.讲到这里眼泪也就出来了,这20%的代码往往都是公司的核心呀,公司的核心那不是你想优化就能优化的,不是说咱实力不行,而是这代码大概率是没有权限看的.如果在28原则里你也遇到了这样的问题,那也不要慌,毕竟还剩下80%的代码,挤一挤也还是能挤出来点的:joy:.

+ 充分利用c++语言自身的优化,让程序支持c++11/14甚至更高.
    
    需要进行大幅度性能优化的项目往往都是老古董了,很多都不支持c++新的语法特性, 而c++11不仅仅是加入了很多易用性的语法特点, 同时也让c++的性能得到了很大的提升,利用新的语法特性对标准库进行了大规模的改写，极大地提高了标准库的性能表现.很多人觉得c++11仅仅是让代码写的更舒服而已,往往忽略了性能这一块的提升.

    在改写CMakeList支持c++11/14后,一编译往往是精彩纷呈,大面积的出错, 不要慌, 因为要支持新特性所以对编译器的要求也就更高了,编译器的升级意味着老古董程序里用到的很多第三方依赖库也就都不能再继续使用了,比如libcrypto、libcurl、libev、libjsoncpp等等就不再罗列了, 通过使用神器[Vcpkg](https://www.jianshu.com/p/f06b8f77bc34)可以很快的完成对这些库的更新. c++自身的优化加上库的更新升级, 这两块弄完,程序的性能已经得到了大幅度的提升. 

+ c++11/14代码层面的性能优化
    
    + 查询频率高的场景, 利用unordered_map 替换 map
    + 避免使用下标访问的方式创建对象, bad: A[1] = "1";good: A.insert(std::make_pair(1,"1")) 前者会多一次不必要的查询.
    + 善用std::move避免不必要的拷贝.

+ 避免频繁的new/delete
    
    局部空间内使用的变量,我们就用普通的局部变量就好,比如command等收发信令,new/delete本身操作就比局部变量的声明和自动析构更耗时,而且大量的new/delete还会造成内存碎片等问题.

+ 避免不必要的拷贝
    
    这部分的优化就需要对程序自身的各个逻辑都搞得比较清楚, 通常情况下拷贝是可以避免的,检查一些临时结构的构造是否必要等. 尤其是针对自定义的结构体和类, 往往拷贝的开销是比较大的. 

+ 日志优化
    
    项目代码在经过很多人的手以后难免就会出现大面积冗余的日志, 建议是将生命周期相关的关键性日志作为info保留,在不影响线上定位问题的前提下对日志进行精简. 同时还可以通过http接口或者定时器定期读取日志配置的方式让程序支持日志打印级别的在线修改.这样线上出问题时现场被保留的同时也可以随时拿到最详细的日志进行分析.

+ 内存池

    内存池是代替直接调用malloc/free、new/delete进行内存管理的常用方法,当我们申请内存空间时,首先到我们的内存池中查找合适的内存块,而不是直接向操作系统申请优势在于可以减少频繁的内存申请和释放,减少申请和释放内存的消耗和内存碎片的产生.
    
+ 算法与细节

    算法尽可能的优化,但是这块需要付出的时间和精力相对较多,而且算法往往提升空间有限.还有一些细节比如位运算代替乘除法,构造函数尽量列表初始化等等,之所以把这两点放到最后,也是在优化工作的过程中发现这些细节的改动真的很难在复杂的线上环境中看到效果.






# 写在最后
本文截止目前重点讨论了面对性能优化问题时的前期准备工作与针对优化c++程序cpu性能的工作积累, 如果有什么问题, 欢迎与我进行交流~ :speech_balloon:  后续如果接触到其他性能相关的工作会在这里继续更新, 敬请期待.:ghost:
